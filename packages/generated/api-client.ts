/**
 * Generated by orval v7.12.2 🍺
 * Do not edit manually.
 * Template Gamma API
 * Next.js 15.5.2 + React 19.0.0 template for Cloudflare Workers with OpenNext
 * OpenAPI spec version: 1.0.0
 */
/**
 * サービスの生存状態
 */
export type LivenessResponseStatus =
  (typeof LivenessResponseStatus)[keyof typeof LivenessResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LivenessResponseStatus = {
  ok: 'ok',
} as const;

export interface LivenessResponse {
  /** サービスの生存状態 */
  status: LivenessResponseStatus;
  /** チェック実行時刻 */
  timestamp: string;
}

/**
 * サービスの準備状態
 */
export type ReadinessResponseStatus =
  (typeof ReadinessResponseStatus)[keyof typeof ReadinessResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReadinessResponseStatus = {
  ok: 'ok',
  degraded: 'degraded',
  down: 'down',
} as const;

export interface ReadinessResponse {
  /** サービスの準備状態 */
  status: ReadinessResponseStatus;
  /** 依存関係のヘルスチェック結果 */
  dependencies: HealthCheck[];
  /** アプリケーションバージョン */
  version: string;
  /** Gitコミットハッシュ */
  commit: string;
  /** ビルド時刻 */
  buildTime: string;
}

/**
 * サービスの診断状態
 */
export type DiagnosticsResponseStatus =
  (typeof DiagnosticsResponseStatus)[keyof typeof DiagnosticsResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DiagnosticsResponseStatus = {
  ok: 'ok',
  degraded: 'degraded',
  down: 'down',
} as const;

export type DiagnosticsResponseDiagnosticsMemory = {
  /** 使用メモリ量（MB） */
  used?: number;
  /** 総メモリ量（MB） */
  total?: number;
};

/**
 * 詳細診断情報
 */
export type DiagnosticsResponseDiagnostics = {
  memory?: DiagnosticsResponseDiagnosticsMemory;
  /** 稼働時間（秒） */
  uptime?: number;
  /** 処理済みリクエスト数 */
  requestCount?: number;
};

export interface DiagnosticsResponse {
  /** サービスの診断状態 */
  status: DiagnosticsResponseStatus;
  /** 依存関係のヘルスチェック結果 */
  dependencies: HealthCheck[];
  /** アプリケーションバージョン */
  version: string;
  /** Gitコミットハッシュ */
  commit: string;
  /** ビルド時刻 */
  buildTime: string;
  /** 詳細診断情報 */
  diagnostics: DiagnosticsResponseDiagnostics;
}

/**
 * チェック結果
 */
export type HealthCheckStatus =
  (typeof HealthCheckStatus)[keyof typeof HealthCheckStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const HealthCheckStatus = {
  ok: 'ok',
  degraded: 'degraded',
  down: 'down',
} as const;

export interface HealthCheck {
  /** チェック対象の名前 */
  name: string;
  /** チェック結果 */
  status: HealthCheckStatus;
  /** レスポンス時間（ミリ秒） */
  latency?: number;
  /** エラーメッセージ（エラー時のみ） */
  error?: string;
}

/**
 * 画像の処理状態
 */
export type ImageResponseStatus =
  (typeof ImageResponseStatus)[keyof typeof ImageResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ImageResponseStatus = {
  uploading: 'uploading',
  processing: 'processing',
  ready: 'ready',
  failed: 'failed',
} as const;

export interface ImageResponse {
  /** 画像ID */
  id: string;
  /** ファイル名 */
  filename: string;
  /** 画像の処理状態 */
  status: ImageResponseStatus;
  /** ファイルサイズ（バイト） */
  fileSize?: number;
  /** MIMEタイプ */
  mimeType?: string;
  /** 作成日時 */
  createdAt: string;
  /** 更新日時 */
  updatedAt?: string;
}

export interface ImageListResponse {
  /** 画像一覧 */
  images: ImageResponse[];
  pagination: Pagination;
}

export interface Pagination {
  /**
   * 現在のページ番号
   * @minimum 1
   */
  page: number;
  /**
   * 1ページあたりの件数
   * @minimum 1
   */
  limit: number;
  /**
   * 総件数
   * @minimum 0
   */
  total: number;
  /** 次のページが存在するか */
  hasNext: boolean;
}

export interface UserResponse {
  /** ユーザーID */
  id: string;
  /** 作成日時 */
  createdAt: string;
  /** 更新日時 */
  updatedAt: string;
  /** 最終ログイン日時 */
  lastLoginAt: string;
}

export interface UserStatsResponse {
  /**
   * 登録からの経過日数
   * @minimum 0
   */
  ageDays: number;
  /**
   * 最終ログインからの経過日数
   * @minimum 0
   */
  daysSinceLastLogin: number;
  /** アクティブユーザーかどうか */
  isActive: boolean;
}

/**
 * エラーの詳細情報
 */
export type ErrorResponseDetails = { [key: string]: unknown };

export interface ErrorResponse {
  /** エラーコード */
  code: string;
  /** エラーメッセージ */
  message: string;
  /** エラーの詳細情報 */
  details?: ErrorResponseDetails;
}

export type ListImagesParams = {
  /**
   * ページ番号
   * @minimum 1
   */
  page?: number;
  /**
   * 1ページあたりの件数
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
};

export type UploadImageBody = {
  /** アップロードする画像ファイル */
  file: Blob;
};

export type GetCurrentUserStatsParams = {
  /**
   * 非アクティブと判定する日数
   * @minimum 1
   * @maximum 365
   */
  inactiveDays?: number;
};

/**
 * 軽量なヘルスチェック（依存関係に触れない）
 * @summary Liveness check
 */
export type getLivenessResponse200 = {
  data: LivenessResponse;
  status: 200;
};

export type getLivenessResponse500 = {
  data: ErrorResponse;
  status: 500;
};

export type getLivenessResponseSuccess = getLivenessResponse200 & {
  headers: Headers;
};
export type getLivenessResponseError = getLivenessResponse500 & {
  headers: Headers;
};

export type getLivenessResponse =
  | getLivenessResponseSuccess
  | getLivenessResponseError;

export const getGetLivenessUrl = () => {
  return `http://localhost:3000/api/healthz`;
};

export const getLiveness = async (
  options?: RequestInit
): Promise<getLivenessResponse> => {
  const res = await fetch(getGetLivenessUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getLivenessResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getLivenessResponse;
};

/**
 * 準備状態確認（Supabase/Storage への到達確認）
 * @summary Readiness check
 */
export type getReadinessResponse200 = {
  data: ReadinessResponse;
  status: 200;
};

export type getReadinessResponse500 = {
  data: ErrorResponse;
  status: 500;
};

export type getReadinessResponse503 = {
  data: ReadinessResponse;
  status: 503;
};

export type getReadinessResponseSuccess = getReadinessResponse200 & {
  headers: Headers;
};
export type getReadinessResponseError = (
  | getReadinessResponse500
  | getReadinessResponse503
) & {
  headers: Headers;
};

export type getReadinessResponse =
  | getReadinessResponseSuccess
  | getReadinessResponseError;

export const getGetReadinessUrl = () => {
  return `http://localhost:3000/api/readyz`;
};

export const getReadiness = async (
  options?: RequestInit
): Promise<getReadinessResponse> => {
  const res = await fetch(getGetReadinessUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getReadinessResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getReadinessResponse;
};

/**
 * 詳細診断情報（認証必須）
 * @summary Diagnostics (auth required)
 */
export type getDiagnosticsResponse200 = {
  data: DiagnosticsResponse;
  status: 200;
};

export type getDiagnosticsResponse401 = {
  data: ErrorResponse;
  status: 401;
};

export type getDiagnosticsResponseSuccess = getDiagnosticsResponse200 & {
  headers: Headers;
};
export type getDiagnosticsResponseError = getDiagnosticsResponse401 & {
  headers: Headers;
};

export type getDiagnosticsResponse =
  | getDiagnosticsResponseSuccess
  | getDiagnosticsResponseError;

export const getGetDiagnosticsUrl = () => {
  return `http://localhost:3000/api/diag`;
};

export const getDiagnostics = async (
  options?: RequestInit
): Promise<getDiagnosticsResponse> => {
  const res = await fetch(getGetDiagnosticsUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getDiagnosticsResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getDiagnosticsResponse;
};

/**
 * ユーザーの画像一覧を取得
 * @summary List user images
 */
export type listImagesResponse200 = {
  data: ImageListResponse;
  status: 200;
};

export type listImagesResponse401 = {
  data: ErrorResponse;
  status: 401;
};

export type listImagesResponseSuccess = listImagesResponse200 & {
  headers: Headers;
};
export type listImagesResponseError = listImagesResponse401 & {
  headers: Headers;
};

export type listImagesResponse =
  | listImagesResponseSuccess
  | listImagesResponseError;

export const getListImagesUrl = (params?: ListImagesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `http://localhost:3000/api/images?${stringifiedParams}`
    : `http://localhost:3000/api/images`;
};

export const listImages = async (
  params?: ListImagesParams,
  options?: RequestInit
): Promise<listImagesResponse> => {
  const res = await fetch(getListImagesUrl(params), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: listImagesResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as listImagesResponse;
};

/**
 * 画像をアップロード
 * @summary Upload image
 */
export type uploadImageResponse201 = {
  data: ImageResponse;
  status: 201;
};

export type uploadImageResponse400 = {
  data: ErrorResponse;
  status: 400;
};

export type uploadImageResponse401 = {
  data: ErrorResponse;
  status: 401;
};

export type uploadImageResponse422 = {
  data: ErrorResponse;
  status: 422;
};

export type uploadImageResponseSuccess = uploadImageResponse201 & {
  headers: Headers;
};
export type uploadImageResponseError = (
  | uploadImageResponse400
  | uploadImageResponse401
  | uploadImageResponse422
) & {
  headers: Headers;
};

export type uploadImageResponse =
  | uploadImageResponseSuccess
  | uploadImageResponseError;

export const getUploadImageUrl = () => {
  return `http://localhost:3000/api/images`;
};

export const uploadImage = async (
  uploadImageBody: UploadImageBody,
  options?: RequestInit
): Promise<uploadImageResponse> => {
  const formData = new FormData();
  formData.append(`file`, uploadImageBody.file);

  const res = await fetch(getUploadImageUrl(), {
    ...options,
    method: 'POST',
    body: formData,
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: uploadImageResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as uploadImageResponse;
};

/**
 * 画像を削除
 * @summary Delete image
 */
export type deleteImageResponse204 = {
  data: void;
  status: 204;
};

export type deleteImageResponse401 = {
  data: ErrorResponse;
  status: 401;
};

export type deleteImageResponse403 = {
  data: ErrorResponse;
  status: 403;
};

export type deleteImageResponse404 = {
  data: ErrorResponse;
  status: 404;
};

export type deleteImageResponseSuccess = deleteImageResponse204 & {
  headers: Headers;
};
export type deleteImageResponseError = (
  | deleteImageResponse401
  | deleteImageResponse403
  | deleteImageResponse404
) & {
  headers: Headers;
};

export type deleteImageResponse =
  | deleteImageResponseSuccess
  | deleteImageResponseError;

export const getDeleteImageUrl = (imageId: string) => {
  return `http://localhost:3000/api/images/${imageId}`;
};

export const deleteImage = async (
  imageId: string,
  options?: RequestInit
): Promise<deleteImageResponse> => {
  const res = await fetch(getDeleteImageUrl(imageId), {
    ...options,
    method: 'DELETE',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: deleteImageResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as deleteImageResponse;
};

/**
 * 現在のユーザー情報を取得
 * @summary Get current user
 */
export type getCurrentUserResponse200 = {
  data: UserResponse;
  status: 200;
};

export type getCurrentUserResponse401 = {
  data: ErrorResponse;
  status: 401;
};

export type getCurrentUserResponseSuccess = getCurrentUserResponse200 & {
  headers: Headers;
};
export type getCurrentUserResponseError = getCurrentUserResponse401 & {
  headers: Headers;
};

export type getCurrentUserResponse =
  | getCurrentUserResponseSuccess
  | getCurrentUserResponseError;

export const getGetCurrentUserUrl = () => {
  return `http://localhost:3000/api/users/me`;
};

export const getCurrentUser = async (
  options?: RequestInit
): Promise<getCurrentUserResponse> => {
  const res = await fetch(getGetCurrentUserUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getCurrentUserResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getCurrentUserResponse;
};

/**
 * 現在のユーザーの最終ログイン時刻を更新
 * @summary Update current user last login
 */
export type updateCurrentUserLastLoginResponse200 = {
  data: UserResponse;
  status: 200;
};

export type updateCurrentUserLastLoginResponse401 = {
  data: ErrorResponse;
  status: 401;
};

export type updateCurrentUserLastLoginResponse404 = {
  data: ErrorResponse;
  status: 404;
};

export type updateCurrentUserLastLoginResponseSuccess =
  updateCurrentUserLastLoginResponse200 & {
    headers: Headers;
  };
export type updateCurrentUserLastLoginResponseError = (
  | updateCurrentUserLastLoginResponse401
  | updateCurrentUserLastLoginResponse404
) & {
  headers: Headers;
};

export type updateCurrentUserLastLoginResponse =
  | updateCurrentUserLastLoginResponseSuccess
  | updateCurrentUserLastLoginResponseError;

export const getUpdateCurrentUserLastLoginUrl = () => {
  return `http://localhost:3000/api/users/me`;
};

export const updateCurrentUserLastLogin = async (
  options?: RequestInit
): Promise<updateCurrentUserLastLoginResponse> => {
  const res = await fetch(getUpdateCurrentUserLastLoginUrl(), {
    ...options,
    method: 'PATCH',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: updateCurrentUserLastLoginResponse['data'] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as updateCurrentUserLastLoginResponse;
};

/**
 * 現在のユーザーの統計情報を取得
 * @summary Get current user statistics
 */
export type getCurrentUserStatsResponse200 = {
  data: UserStatsResponse;
  status: 200;
};

export type getCurrentUserStatsResponse401 = {
  data: ErrorResponse;
  status: 401;
};

export type getCurrentUserStatsResponse404 = {
  data: ErrorResponse;
  status: 404;
};

export type getCurrentUserStatsResponse422 = {
  data: ErrorResponse;
  status: 422;
};

export type getCurrentUserStatsResponseSuccess =
  getCurrentUserStatsResponse200 & {
    headers: Headers;
  };
export type getCurrentUserStatsResponseError = (
  | getCurrentUserStatsResponse401
  | getCurrentUserStatsResponse404
  | getCurrentUserStatsResponse422
) & {
  headers: Headers;
};

export type getCurrentUserStatsResponse =
  | getCurrentUserStatsResponseSuccess
  | getCurrentUserStatsResponseError;

export const getGetCurrentUserStatsUrl = (
  params?: GetCurrentUserStatsParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `http://localhost:3000/api/users/me/stats?${stringifiedParams}`
    : `http://localhost:3000/api/users/me/stats`;
};

export const getCurrentUserStats = async (
  params?: GetCurrentUserStatsParams,
  options?: RequestInit
): Promise<getCurrentUserStatsResponse> => {
  const res = await fetch(getGetCurrentUserStatsUrl(params), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getCurrentUserStatsResponse['data'] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getCurrentUserStatsResponse;
};
