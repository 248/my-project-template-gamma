/**
 * Generated by orval v7.12.2 ðŸº
 * Do not edit manually.
 * Template Gamma API
 * Next.js 15.5.2 + React 19.0.0 template for Cloudflare Workers with OpenNext
 * OpenAPI spec version: 1.0.0
 */
/**
 * ã‚µãƒ¼ãƒ“ã‚¹ã®ç”Ÿå­˜çŠ¶æ…‹
 */
export type LivenessResponseStatus =
  (typeof LivenessResponseStatus)[keyof typeof LivenessResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LivenessResponseStatus = {
  ok: 'ok',
} as const;

export interface LivenessResponse {
  /** ã‚µãƒ¼ãƒ“ã‚¹ã®ç”Ÿå­˜çŠ¶æ…‹ */
  status: LivenessResponseStatus;
  /** ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œæ™‚åˆ» */
  timestamp: string;
}

/**
 * ã‚µãƒ¼ãƒ“ã‚¹ã®æº–å‚™çŠ¶æ…‹
 */
export type ReadinessResponseStatus =
  (typeof ReadinessResponseStatus)[keyof typeof ReadinessResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReadinessResponseStatus = {
  ok: 'ok',
  degraded: 'degraded',
  down: 'down',
} as const;

export interface ReadinessResponse {
  /** ã‚µãƒ¼ãƒ“ã‚¹ã®æº–å‚™çŠ¶æ…‹ */
  status: ReadinessResponseStatus;
  /** ä¾å­˜é–¢ä¿‚ã®ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯çµæžœ */
  dependencies: HealthCheck[];
  /** ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ã‚¸ãƒ§ãƒ³ */
  version: string;
  /** Gitã‚³ãƒŸãƒƒãƒˆãƒãƒƒã‚·ãƒ¥ */
  commit: string;
  /** ãƒ“ãƒ«ãƒ‰æ™‚åˆ» */
  buildTime: string;
}

/**
 * ã‚µãƒ¼ãƒ“ã‚¹ã®è¨ºæ–­çŠ¶æ…‹
 */
export type DiagnosticsResponseStatus =
  (typeof DiagnosticsResponseStatus)[keyof typeof DiagnosticsResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DiagnosticsResponseStatus = {
  ok: 'ok',
  degraded: 'degraded',
  down: 'down',
} as const;

export type DiagnosticsResponseDiagnosticsMemory = {
  /** ä½¿ç”¨ãƒ¡ãƒ¢ãƒªé‡ï¼ˆMBï¼‰ */
  used?: number;
  /** ç·ãƒ¡ãƒ¢ãƒªé‡ï¼ˆMBï¼‰ */
  total?: number;
};

/**
 * è©³ç´°è¨ºæ–­æƒ…å ±
 */
export type DiagnosticsResponseDiagnostics = {
  memory?: DiagnosticsResponseDiagnosticsMemory;
  /** ç¨¼åƒæ™‚é–“ï¼ˆç§’ï¼‰ */
  uptime?: number;
  /** å‡¦ç†æ¸ˆã¿ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ•° */
  requestCount?: number;
};

export interface DiagnosticsResponse {
  /** ã‚µãƒ¼ãƒ“ã‚¹ã®è¨ºæ–­çŠ¶æ…‹ */
  status: DiagnosticsResponseStatus;
  /** ä¾å­˜é–¢ä¿‚ã®ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯çµæžœ */
  dependencies: HealthCheck[];
  /** ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ã‚¸ãƒ§ãƒ³ */
  version: string;
  /** Gitã‚³ãƒŸãƒƒãƒˆãƒãƒƒã‚·ãƒ¥ */
  commit: string;
  /** ãƒ“ãƒ«ãƒ‰æ™‚åˆ» */
  buildTime: string;
  /** è©³ç´°è¨ºæ–­æƒ…å ± */
  diagnostics: DiagnosticsResponseDiagnostics;
}

/**
 * ãƒã‚§ãƒƒã‚¯çµæžœ
 */
export type HealthCheckStatus =
  (typeof HealthCheckStatus)[keyof typeof HealthCheckStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const HealthCheckStatus = {
  ok: 'ok',
  degraded: 'degraded',
  down: 'down',
} as const;

export interface HealthCheck {
  /** ãƒã‚§ãƒƒã‚¯å¯¾è±¡ã®åå‰ */
  name: string;
  /** ãƒã‚§ãƒƒã‚¯çµæžœ */
  status: HealthCheckStatus;
  /** ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰ */
  latency?: number;
  /** ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆã‚¨ãƒ©ãƒ¼æ™‚ã®ã¿ï¼‰ */
  error?: string;
}

/**
 * ç”»åƒã®å‡¦ç†çŠ¶æ…‹
 */
export type ImageResponseStatus =
  (typeof ImageResponseStatus)[keyof typeof ImageResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ImageResponseStatus = {
  uploading: 'uploading',
  processing: 'processing',
  ready: 'ready',
  failed: 'failed',
} as const;

export interface ImageResponse {
  /** ç”»åƒID */
  id: string;
  /** ãƒ•ã‚¡ã‚¤ãƒ«å */
  filename: string;
  /** ç”»åƒã®å‡¦ç†çŠ¶æ…‹ */
  status: ImageResponseStatus;
  /** ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºï¼ˆãƒã‚¤ãƒˆï¼‰ */
  fileSize?: number;
  /** MIMEã‚¿ã‚¤ãƒ— */
  mimeType?: string;
  /** ä½œæˆæ—¥æ™‚ */
  createdAt: string;
  /** æ›´æ–°æ—¥æ™‚ */
  updatedAt?: string;
}

export interface ImageListResponse {
  /** ç”»åƒä¸€è¦§ */
  images: ImageResponse[];
  pagination: Pagination;
}

export interface Pagination {
  /**
   * ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ç•ªå·
   * @minimum 1
   */
  page: number;
  /**
   * 1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°
   * @minimum 1
   */
  limit: number;
  /**
   * ç·ä»¶æ•°
   * @minimum 0
   */
  total: number;
  /** æ¬¡ã®ãƒšãƒ¼ã‚¸ãŒå­˜åœ¨ã™ã‚‹ã‹ */
  hasNext: boolean;
}

export interface UserResponse {
  /** ãƒ¦ãƒ¼ã‚¶ãƒ¼ID */
  id: string;
  /** ä½œæˆæ—¥æ™‚ */
  createdAt: string;
  /** æ›´æ–°æ—¥æ™‚ */
  updatedAt: string;
  /** æœ€çµ‚ãƒ­ã‚°ã‚¤ãƒ³æ—¥æ™‚ */
  lastLoginAt: string;
}

export interface UserStatsResponse {
  /**
   * ç™»éŒ²ã‹ã‚‰ã®çµŒéŽæ—¥æ•°
   * @minimum 0
   */
  ageDays: number;
  /**
   * æœ€çµ‚ãƒ­ã‚°ã‚¤ãƒ³ã‹ã‚‰ã®çµŒéŽæ—¥æ•°
   * @minimum 0
   */
  daysSinceLastLogin: number;
  /** ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã©ã†ã‹ */
  isActive: boolean;
}

/**
 * ã‚¨ãƒ©ãƒ¼ã®è©³ç´°æƒ…å ±
 */
export type ErrorResponseDetails = { [key: string]: unknown };

export interface ErrorResponse {
  /** ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ */
  code: string;
  /** ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */
  message: string;
  /** ã‚¨ãƒ©ãƒ¼ã®è©³ç´°æƒ…å ± */
  details?: ErrorResponseDetails;
}

export type ListImagesParams = {
  /**
   * ãƒšãƒ¼ã‚¸ç•ªå·
   * @minimum 1
   */
  page?: number;
  /**
   * 1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
};

export type UploadImageBody = {
  /** ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ç”»åƒãƒ•ã‚¡ã‚¤ãƒ« */
  file: Blob;
};

export type GetCurrentUserStatsParams = {
  /**
   * éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã¨åˆ¤å®šã™ã‚‹æ—¥æ•°
   * @minimum 1
   * @maximum 365
   */
  inactiveDays?: number;
};

/**
 * è»½é‡ãªãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ï¼ˆä¾å­˜é–¢ä¿‚ã«è§¦ã‚Œãªã„ï¼‰
 * @summary Liveness check
 */
export type getLivenessResponse200 = {
  data: LivenessResponse;
  status: 200;
};

export type getLivenessResponse500 = {
  data: ErrorResponse;
  status: 500;
};

export type getLivenessResponseSuccess = getLivenessResponse200 & {
  headers: Headers;
};
export type getLivenessResponseError = getLivenessResponse500 & {
  headers: Headers;
};

export type getLivenessResponse =
  | getLivenessResponseSuccess
  | getLivenessResponseError;

export const getGetLivenessUrl = () => {
  return `http://localhost:3000/api/healthz`;
};

export const getLiveness = async (
  options?: RequestInit
): Promise<getLivenessResponse> => {
  const res = await fetch(getGetLivenessUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getLivenessResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getLivenessResponse;
};

/**
 * æº–å‚™çŠ¶æ…‹ç¢ºèªï¼ˆSupabase/Storage ã¸ã®åˆ°é”ç¢ºèªï¼‰
 * @summary Readiness check
 */
export type getReadinessResponse200 = {
  data: ReadinessResponse;
  status: 200;
};

export type getReadinessResponse500 = {
  data: ErrorResponse;
  status: 500;
};

export type getReadinessResponse503 = {
  data: ReadinessResponse;
  status: 503;
};

export type getReadinessResponseSuccess = getReadinessResponse200 & {
  headers: Headers;
};
export type getReadinessResponseError = (
  | getReadinessResponse500
  | getReadinessResponse503
) & {
  headers: Headers;
};

export type getReadinessResponse =
  | getReadinessResponseSuccess
  | getReadinessResponseError;

export const getGetReadinessUrl = () => {
  return `http://localhost:3000/api/readyz`;
};

export const getReadiness = async (
  options?: RequestInit
): Promise<getReadinessResponse> => {
  const res = await fetch(getGetReadinessUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getReadinessResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getReadinessResponse;
};

/**
 * è©³ç´°è¨ºæ–­æƒ…å ±ï¼ˆèªè¨¼å¿…é ˆï¼‰
 * @summary Diagnostics (auth required)
 */
export type getDiagnosticsResponse200 = {
  data: DiagnosticsResponse;
  status: 200;
};

export type getDiagnosticsResponse401 = {
  data: ErrorResponse;
  status: 401;
};

export type getDiagnosticsResponseSuccess = getDiagnosticsResponse200 & {
  headers: Headers;
};
export type getDiagnosticsResponseError = getDiagnosticsResponse401 & {
  headers: Headers;
};

export type getDiagnosticsResponse =
  | getDiagnosticsResponseSuccess
  | getDiagnosticsResponseError;

export const getGetDiagnosticsUrl = () => {
  return `http://localhost:3000/api/diag`;
};

export const getDiagnostics = async (
  options?: RequestInit
): Promise<getDiagnosticsResponse> => {
  const res = await fetch(getGetDiagnosticsUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getDiagnosticsResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getDiagnosticsResponse;
};

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ç”»åƒä¸€è¦§ã‚’å–å¾—
 * @summary List user images
 */
export type listImagesResponse200 = {
  data: ImageListResponse;
  status: 200;
};

export type listImagesResponse401 = {
  data: ErrorResponse;
  status: 401;
};

export type listImagesResponseSuccess = listImagesResponse200 & {
  headers: Headers;
};
export type listImagesResponseError = listImagesResponse401 & {
  headers: Headers;
};

export type listImagesResponse =
  | listImagesResponseSuccess
  | listImagesResponseError;

export const getListImagesUrl = (params?: ListImagesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `http://localhost:3000/api/images?${stringifiedParams}`
    : `http://localhost:3000/api/images`;
};

export const listImages = async (
  params?: ListImagesParams,
  options?: RequestInit
): Promise<listImagesResponse> => {
  const res = await fetch(getListImagesUrl(params), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: listImagesResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as listImagesResponse;
};

/**
 * ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
 * @summary Upload image
 */
export type uploadImageResponse201 = {
  data: ImageResponse;
  status: 201;
};

export type uploadImageResponse400 = {
  data: ErrorResponse;
  status: 400;
};

export type uploadImageResponse401 = {
  data: ErrorResponse;
  status: 401;
};

export type uploadImageResponse422 = {
  data: ErrorResponse;
  status: 422;
};

export type uploadImageResponseSuccess = uploadImageResponse201 & {
  headers: Headers;
};
export type uploadImageResponseError = (
  | uploadImageResponse400
  | uploadImageResponse401
  | uploadImageResponse422
) & {
  headers: Headers;
};

export type uploadImageResponse =
  | uploadImageResponseSuccess
  | uploadImageResponseError;

export const getUploadImageUrl = () => {
  return `http://localhost:3000/api/images`;
};

export const uploadImage = async (
  uploadImageBody: UploadImageBody,
  options?: RequestInit
): Promise<uploadImageResponse> => {
  const formData = new FormData();
  formData.append(`file`, uploadImageBody.file);

  const res = await fetch(getUploadImageUrl(), {
    ...options,
    method: 'POST',
    body: formData,
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: uploadImageResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as uploadImageResponse;
};

/**
 * ç”»åƒã‚’å‰Šé™¤
 * @summary Delete image
 */
export type deleteImageResponse204 = {
  data: void;
  status: 204;
};

export type deleteImageResponse401 = {
  data: ErrorResponse;
  status: 401;
};

export type deleteImageResponse403 = {
  data: ErrorResponse;
  status: 403;
};

export type deleteImageResponse404 = {
  data: ErrorResponse;
  status: 404;
};

export type deleteImageResponseSuccess = deleteImageResponse204 & {
  headers: Headers;
};
export type deleteImageResponseError = (
  | deleteImageResponse401
  | deleteImageResponse403
  | deleteImageResponse404
) & {
  headers: Headers;
};

export type deleteImageResponse =
  | deleteImageResponseSuccess
  | deleteImageResponseError;

export const getDeleteImageUrl = (imageId: string) => {
  return `http://localhost:3000/api/images/${imageId}`;
};

export const deleteImage = async (
  imageId: string,
  options?: RequestInit
): Promise<deleteImageResponse> => {
  const res = await fetch(getDeleteImageUrl(imageId), {
    ...options,
    method: 'DELETE',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: deleteImageResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as deleteImageResponse;
};

/**
 * ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—
 * @summary Get current user
 */
export type getCurrentUserResponse200 = {
  data: UserResponse;
  status: 200;
};

export type getCurrentUserResponse401 = {
  data: ErrorResponse;
  status: 401;
};

export type getCurrentUserResponseSuccess = getCurrentUserResponse200 & {
  headers: Headers;
};
export type getCurrentUserResponseError = getCurrentUserResponse401 & {
  headers: Headers;
};

export type getCurrentUserResponse =
  | getCurrentUserResponseSuccess
  | getCurrentUserResponseError;

export const getGetCurrentUserUrl = () => {
  return `http://localhost:3000/api/users/me`;
};

export const getCurrentUser = async (
  options?: RequestInit
): Promise<getCurrentUserResponse> => {
  const res = await fetch(getGetCurrentUserUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getCurrentUserResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getCurrentUserResponse;
};

/**
 * ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æœ€çµ‚ãƒ­ã‚°ã‚¤ãƒ³æ™‚åˆ»ã‚’æ›´æ–°
 * @summary Update current user last login
 */
export type updateCurrentUserLastLoginResponse200 = {
  data: UserResponse;
  status: 200;
};

export type updateCurrentUserLastLoginResponse401 = {
  data: ErrorResponse;
  status: 401;
};

export type updateCurrentUserLastLoginResponse404 = {
  data: ErrorResponse;
  status: 404;
};

export type updateCurrentUserLastLoginResponseSuccess =
  updateCurrentUserLastLoginResponse200 & {
    headers: Headers;
  };
export type updateCurrentUserLastLoginResponseError = (
  | updateCurrentUserLastLoginResponse401
  | updateCurrentUserLastLoginResponse404
) & {
  headers: Headers;
};

export type updateCurrentUserLastLoginResponse =
  | updateCurrentUserLastLoginResponseSuccess
  | updateCurrentUserLastLoginResponseError;

export const getUpdateCurrentUserLastLoginUrl = () => {
  return `http://localhost:3000/api/users/me`;
};

export const updateCurrentUserLastLogin = async (
  options?: RequestInit
): Promise<updateCurrentUserLastLoginResponse> => {
  const res = await fetch(getUpdateCurrentUserLastLoginUrl(), {
    ...options,
    method: 'PATCH',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: updateCurrentUserLastLoginResponse['data'] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as updateCurrentUserLastLoginResponse;
};

/**
 * ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾—
 * @summary Get current user statistics
 */
export type getCurrentUserStatsResponse200 = {
  data: UserStatsResponse;
  status: 200;
};

export type getCurrentUserStatsResponse401 = {
  data: ErrorResponse;
  status: 401;
};

export type getCurrentUserStatsResponse404 = {
  data: ErrorResponse;
  status: 404;
};

export type getCurrentUserStatsResponse422 = {
  data: ErrorResponse;
  status: 422;
};

export type getCurrentUserStatsResponseSuccess =
  getCurrentUserStatsResponse200 & {
    headers: Headers;
  };
export type getCurrentUserStatsResponseError = (
  | getCurrentUserStatsResponse401
  | getCurrentUserStatsResponse404
  | getCurrentUserStatsResponse422
) & {
  headers: Headers;
};

export type getCurrentUserStatsResponse =
  | getCurrentUserStatsResponseSuccess
  | getCurrentUserStatsResponseError;

export const getGetCurrentUserStatsUrl = (
  params?: GetCurrentUserStatsParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `http://localhost:3000/api/users/me/stats?${stringifiedParams}`
    : `http://localhost:3000/api/users/me/stats`;
};

export const getCurrentUserStats = async (
  params?: GetCurrentUserStatsParams,
  options?: RequestInit
): Promise<getCurrentUserStatsResponse> => {
  const res = await fetch(getGetCurrentUserStatsUrl(params), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getCurrentUserStatsResponse['data'] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getCurrentUserStatsResponse;
};
